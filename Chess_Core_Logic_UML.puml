@startuml Chess Core Logic

' Core Game Logic
class Board {
  -HashSet<Piece> _pieces
  -King _whiteKing
  -King _blackKing
  +Piece GetPieceAt(Position pos)
  +bool IsEmpty(Position pos)
  +bool IsInCheck(Player player)
  +HashSet<Move> GetAllyMoves(Player player)
}

class MatchState {
  -Board _board
  -Player _currentPlayer
  -Move _lastMove
  -Clock _whiteClock
  -Clock _blackClock
  +Player CurrentPlayer
  +void MakeMove(Move move)
  +bool IsLegalMove(Move move)
  +bool MoveResolvesCheck(Move move, Player player)
}

enum Player {
  White
  Black
}

' Piece Hierarchy
abstract class Piece {
  +Player Color
  +Position Position
  +bool HasMoved
  +char PieceChar
  +PieceType Type
  +Board MyBoard
  +HashSet<Move> GetLegalMoves()
  +{abstract} HashSet<Move> GetMoves()
  +virtual IEnumerable<Move> GetAttackedSquares()
}

class King extends Piece {
  +override HashSet<Move> GetMoves()
}

class Queen extends SlidingPiece {
  +override HashSet<Move> GetMoves()
}

class Rook extends SlidingPiece {
  +override HashSet<Move> GetMoves()
}

class Bishop extends SlidingPiece {
  +override HashSet<Move> GetMoves()
}

class Knight extends Piece {
  +override HashSet<Move> GetMoves()
}

class Pawn extends Piece {
  +override HashSet<Move> GetMoves()
}

abstract class SlidingPiece extends Piece {
  +override HashSet<Move> GetMoves()
}

enum PieceType {
  Pawn
  Rook
  Knight
  Bishop
  Queen
  King
}

class PieceFactory {
  +static HashSet<Piece> CreatePieces(Board board)
  +static PieceType GetPieceType(char pieceChar)
}

' Move System
abstract class Move {
  +{abstract} MoveType Type
  +{abstract} Position From
  +{abstract} Position To
  +{abstract} Piece MovedPiece
  +{abstract} Piece CapturedPiece
  +{abstract} void Execute(Board board, bool isSimulation)
  +{abstract} void Undo(Board board, bool isSimulation)
}

enum MoveType {
  Normal
  CastleKS
  CastleQS
  DoublePawn
  EnPassant
  Promotion
}

class NormalMove extends Move {
  +override void Execute(Board board, bool isSimulation)
  +override void Undo(Board board, bool isSimulation)
}

class CastleMove extends Move {
  +override void Execute(Board board, bool isSimulation)
  +override void Undo(Board board, bool isSimulation)
}

class EnPassantMove extends Move {
  +override void Execute(Board board, bool isSimulation)
  +override void Undo(Board board, bool isSimulation)
}

class DoublePawnMove extends Move {
  +override void Execute(Board board, bool isSimulation)
  +override void Undo(Board board, bool isSimulation)
}

class PromotionMove extends Move {
  +override void Execute(Board board, bool isSimulation)
  +override void Undo(Board board, bool isSimulation)
}

' Positioning
class Position {
  +int Rank
  +int File
  +Position(int file, int rank)
  +Position Copy()
}

class Direction {
  +int DeltaX
  +int DeltaY
  +static Direction North
  +static Direction South
  +static Direction East
  +static Direction West
  +static Direction NorthEast
  +static Direction NorthWest
  +static Direction SouthEast
  +static Direction SouthWest
}

' Key Relationships
Board "1" --> "*" Piece : contains
Board --> King : tracks
MatchState --> Board : operates on
MatchState --> Player : tracks current
MatchState --> Move : tracks last move
Piece --> Board : references
Piece --> Position : has location
Piece --> PieceType : has type
Piece ..> Move : creates
Move --> Piece : references
Move --> Position : has from/to
PieceFactory ..> Piece : creates
Direction ..> Position : modifies

' Specialized Relationships
SlidingPiece ..> Direction : uses for movement
King ..> CastleMove : can create
Pawn ..> EnPassantMove : can create 
Pawn ..> DoublePawnMove : can create
Pawn ..> PromotionMove : can create

@enduml 